// --------------------------------------------------------------------------------------------
// Copyright (c) 2019 The CefNet Authors. All rights reserved.
// Licensed under the MIT license.
// See the licence file in the project root for full license information.
// --------------------------------------------------------------------------------------------
// Generated by CefGen
// Source: Generated/Native/Types/cef_v8interceptor_t.cs
// --------------------------------------------------------------------------------------------﻿
// DO NOT MODIFY! THIS IS AUTOGENERATED FILE!
// --------------------------------------------------------------------------------------------

#pragma warning disable 0169

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using CefNet.WinApi;
using CefNet.CApi;
using CefNet.Internal;

namespace CefNet
{
	/// <summary>
	/// Structure that should be implemented to handle V8 interceptor calls. The
	/// functions of this structure will be called on the thread associated with the
	/// V8 interceptor. Interceptor&apos;s named property handlers (with first argument of
	/// type CefString) are called when object is indexed by string. Indexed property
	/// handlers (with first argument of type int) are called when object is indexed
	/// by integer.
	/// </summary>
	/// <remarks>
	/// Role: Proxy
	/// </remarks>
	public unsafe partial class CefV8Interceptor : CefBaseRefCounted<cef_v8interceptor_t>
	{
		internal static unsafe CefV8Interceptor Create(IntPtr instance)
		{
			return new CefV8Interceptor((cef_v8interceptor_t*)instance);
		}

		public CefV8Interceptor(cef_v8interceptor_t* instance)
			: base((cef_base_ref_counted_t*)instance)
		{
		}

		/// <summary>
		/// Handle retrieval of the interceptor value identified by |name|. |object| is
		/// the receiver (&apos;this&apos; object) of the interceptor. If retrieval succeeds, set
		/// |retval| to the return value. If the requested value does not exist, don&apos;t
		/// set either |retval| or |exception|. If retrieval fails, set |exception| to
		/// the exception that will be thrown. If the property has an associated
		/// accessor, it will be called only if you don&apos;t set |retval|. Return true (1)
		/// if interceptor retrieval was handled, false (0) otherwise.
		/// </summary>
		public unsafe virtual bool GetByName(string name, CefV8Value @object, ref CefV8Value retval, ref string exception)
		{
			fixed (char* s0 = name)
			fixed (char* s3 = exception)
			{
				var cstr0 = new cef_string_t { Str = s0, Length = name != null ? name.Length : 0 };
				cef_v8value_t* p2 = (retval != null) ? retval.GetNativeInstance() : null;
				cef_v8value_t** pp2 = &p2;
				var cstr3 = new cef_string_t { Str = s3, Length = exception != null ? exception.Length : 0 };
				var rv = NativeInstance->GetByName(&cstr0, (@object != null) ? @object.GetNativeInstance() : null, pp2, &cstr3) != 0;
				retval = CefV8Value.Wrap(CefV8Value.Create, p2);
				exception = CefString.ReadAndFree(&cstr3);
				GC.KeepAlive(this);
				return rv;
			}
		}

		/// <summary>
		/// Handle retrieval of the interceptor value identified by |index|. |object|
		/// is the receiver (&apos;this&apos; object) of the interceptor. If retrieval succeeds,
		/// set |retval| to the return value. If the requested value does not exist,
		/// don&apos;t set either |retval| or |exception|. If retrieval fails, set
		/// |exception| to the exception that will be thrown. Return true (1) if
		/// interceptor retrieval was handled, false (0) otherwise.
		/// </summary>
		public unsafe virtual bool GetByIndex(int index, CefV8Value @object, ref CefV8Value retval, ref string exception)
		{
			fixed (char* s3 = exception)
			{
				cef_v8value_t* p2 = (retval != null) ? retval.GetNativeInstance() : null;
				cef_v8value_t** pp2 = &p2;
				var cstr3 = new cef_string_t { Str = s3, Length = exception != null ? exception.Length : 0 };
				var rv = NativeInstance->GetByIndex(index, (@object != null) ? @object.GetNativeInstance() : null, pp2, &cstr3) != 0;
				retval = CefV8Value.Wrap(CefV8Value.Create, p2);
				exception = CefString.ReadAndFree(&cstr3);
				GC.KeepAlive(this);
				return rv;
			}
		}

		/// <summary>
		/// Handle assignment of the interceptor value identified by |name|. |object|
		/// is the receiver (&apos;this&apos; object) of the interceptor. |value| is the new
		/// value being assigned to the interceptor. If assignment fails, set
		/// |exception| to the exception that will be thrown. This setter will always
		/// be called, even when the property has an associated accessor. Return true
		/// (1) if interceptor assignment was handled, false (0) otherwise.
		/// </summary>
		public unsafe virtual bool SetByName(string name, CefV8Value @object, CefV8Value value, ref string exception)
		{
			fixed (char* s0 = name)
			fixed (char* s3 = exception)
			{
				var cstr0 = new cef_string_t { Str = s0, Length = name != null ? name.Length : 0 };
				var cstr3 = new cef_string_t { Str = s3, Length = exception != null ? exception.Length : 0 };
				var rv = NativeInstance->SetByName(&cstr0, (@object != null) ? @object.GetNativeInstance() : null, (value != null) ? value.GetNativeInstance() : null, &cstr3) != 0;
				exception = CefString.ReadAndFree(&cstr3);
				GC.KeepAlive(this);
				return rv;
			}
		}

		/// <summary>
		/// Handle assignment of the interceptor value identified by |index|. |object|
		/// is the receiver (&apos;this&apos; object) of the interceptor. |value| is the new
		/// value being assigned to the interceptor. If assignment fails, set
		/// |exception| to the exception that will be thrown. Return true (1) if
		/// interceptor assignment was handled, false (0) otherwise.
		/// </summary>
		public unsafe virtual bool SetByIndex(int index, CefV8Value @object, CefV8Value value, ref string exception)
		{
			fixed (char* s3 = exception)
			{
				var cstr3 = new cef_string_t { Str = s3, Length = exception != null ? exception.Length : 0 };
				var rv = NativeInstance->SetByIndex(index, (@object != null) ? @object.GetNativeInstance() : null, (value != null) ? value.GetNativeInstance() : null, &cstr3) != 0;
				exception = CefString.ReadAndFree(&cstr3);
				GC.KeepAlive(this);
				return rv;
			}
		}
	}
}
